// Code generated by counterfeiter. DO NOT EDIT.
package collectorfakes

import (
	"lca/internal/app/collector"
	"sync"
)

type FakeJobData struct {
	DoneChannelStub        func() chan any
	doneChannelMutex       sync.RWMutex
	doneChannelArgsForCall []struct {
	}
	doneChannelReturns struct {
		result1 chan any
	}
	doneChannelReturnsOnCall map[int]struct {
		result1 chan any
	}
	ErrorChannelStub        func() chan error
	errorChannelMutex       sync.RWMutex
	errorChannelArgsForCall []struct {
	}
	errorChannelReturns struct {
		result1 chan error
	}
	errorChannelReturnsOnCall map[int]struct {
		result1 chan error
	}
	StderrChannelStub        func() chan []byte
	stderrChannelMutex       sync.RWMutex
	stderrChannelArgsForCall []struct {
	}
	stderrChannelReturns struct {
		result1 chan []byte
	}
	stderrChannelReturnsOnCall map[int]struct {
		result1 chan []byte
	}
	StdoutChannelStub        func() chan []byte
	stdoutChannelMutex       sync.RWMutex
	stdoutChannelArgsForCall []struct {
	}
	stdoutChannelReturns struct {
		result1 chan []byte
	}
	stdoutChannelReturnsOnCall map[int]struct {
		result1 chan []byte
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJobData) DoneChannel() chan any {
	fake.doneChannelMutex.Lock()
	ret, specificReturn := fake.doneChannelReturnsOnCall[len(fake.doneChannelArgsForCall)]
	fake.doneChannelArgsForCall = append(fake.doneChannelArgsForCall, struct {
	}{})
	stub := fake.DoneChannelStub
	fakeReturns := fake.doneChannelReturns
	fake.recordInvocation("DoneChannel", []interface{}{})
	fake.doneChannelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeJobData) DoneChannelCallCount() int {
	fake.doneChannelMutex.RLock()
	defer fake.doneChannelMutex.RUnlock()
	return len(fake.doneChannelArgsForCall)
}

func (fake *FakeJobData) DoneChannelCalls(stub func() chan any) {
	fake.doneChannelMutex.Lock()
	defer fake.doneChannelMutex.Unlock()
	fake.DoneChannelStub = stub
}

func (fake *FakeJobData) DoneChannelReturns(result1 chan any) {
	fake.doneChannelMutex.Lock()
	defer fake.doneChannelMutex.Unlock()
	fake.DoneChannelStub = nil
	fake.doneChannelReturns = struct {
		result1 chan any
	}{result1}
}

func (fake *FakeJobData) DoneChannelReturnsOnCall(i int, result1 chan any) {
	fake.doneChannelMutex.Lock()
	defer fake.doneChannelMutex.Unlock()
	fake.DoneChannelStub = nil
	if fake.doneChannelReturnsOnCall == nil {
		fake.doneChannelReturnsOnCall = make(map[int]struct {
			result1 chan any
		})
	}
	fake.doneChannelReturnsOnCall[i] = struct {
		result1 chan any
	}{result1}
}

func (fake *FakeJobData) ErrorChannel() chan error {
	fake.errorChannelMutex.Lock()
	ret, specificReturn := fake.errorChannelReturnsOnCall[len(fake.errorChannelArgsForCall)]
	fake.errorChannelArgsForCall = append(fake.errorChannelArgsForCall, struct {
	}{})
	stub := fake.ErrorChannelStub
	fakeReturns := fake.errorChannelReturns
	fake.recordInvocation("ErrorChannel", []interface{}{})
	fake.errorChannelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeJobData) ErrorChannelCallCount() int {
	fake.errorChannelMutex.RLock()
	defer fake.errorChannelMutex.RUnlock()
	return len(fake.errorChannelArgsForCall)
}

func (fake *FakeJobData) ErrorChannelCalls(stub func() chan error) {
	fake.errorChannelMutex.Lock()
	defer fake.errorChannelMutex.Unlock()
	fake.ErrorChannelStub = stub
}

func (fake *FakeJobData) ErrorChannelReturns(result1 chan error) {
	fake.errorChannelMutex.Lock()
	defer fake.errorChannelMutex.Unlock()
	fake.ErrorChannelStub = nil
	fake.errorChannelReturns = struct {
		result1 chan error
	}{result1}
}

func (fake *FakeJobData) ErrorChannelReturnsOnCall(i int, result1 chan error) {
	fake.errorChannelMutex.Lock()
	defer fake.errorChannelMutex.Unlock()
	fake.ErrorChannelStub = nil
	if fake.errorChannelReturnsOnCall == nil {
		fake.errorChannelReturnsOnCall = make(map[int]struct {
			result1 chan error
		})
	}
	fake.errorChannelReturnsOnCall[i] = struct {
		result1 chan error
	}{result1}
}

func (fake *FakeJobData) StderrChannel() chan []byte {
	fake.stderrChannelMutex.Lock()
	ret, specificReturn := fake.stderrChannelReturnsOnCall[len(fake.stderrChannelArgsForCall)]
	fake.stderrChannelArgsForCall = append(fake.stderrChannelArgsForCall, struct {
	}{})
	stub := fake.StderrChannelStub
	fakeReturns := fake.stderrChannelReturns
	fake.recordInvocation("StderrChannel", []interface{}{})
	fake.stderrChannelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeJobData) StderrChannelCallCount() int {
	fake.stderrChannelMutex.RLock()
	defer fake.stderrChannelMutex.RUnlock()
	return len(fake.stderrChannelArgsForCall)
}

func (fake *FakeJobData) StderrChannelCalls(stub func() chan []byte) {
	fake.stderrChannelMutex.Lock()
	defer fake.stderrChannelMutex.Unlock()
	fake.StderrChannelStub = stub
}

func (fake *FakeJobData) StderrChannelReturns(result1 chan []byte) {
	fake.stderrChannelMutex.Lock()
	defer fake.stderrChannelMutex.Unlock()
	fake.StderrChannelStub = nil
	fake.stderrChannelReturns = struct {
		result1 chan []byte
	}{result1}
}

func (fake *FakeJobData) StderrChannelReturnsOnCall(i int, result1 chan []byte) {
	fake.stderrChannelMutex.Lock()
	defer fake.stderrChannelMutex.Unlock()
	fake.StderrChannelStub = nil
	if fake.stderrChannelReturnsOnCall == nil {
		fake.stderrChannelReturnsOnCall = make(map[int]struct {
			result1 chan []byte
		})
	}
	fake.stderrChannelReturnsOnCall[i] = struct {
		result1 chan []byte
	}{result1}
}

func (fake *FakeJobData) StdoutChannel() chan []byte {
	fake.stdoutChannelMutex.Lock()
	ret, specificReturn := fake.stdoutChannelReturnsOnCall[len(fake.stdoutChannelArgsForCall)]
	fake.stdoutChannelArgsForCall = append(fake.stdoutChannelArgsForCall, struct {
	}{})
	stub := fake.StdoutChannelStub
	fakeReturns := fake.stdoutChannelReturns
	fake.recordInvocation("StdoutChannel", []interface{}{})
	fake.stdoutChannelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeJobData) StdoutChannelCallCount() int {
	fake.stdoutChannelMutex.RLock()
	defer fake.stdoutChannelMutex.RUnlock()
	return len(fake.stdoutChannelArgsForCall)
}

func (fake *FakeJobData) StdoutChannelCalls(stub func() chan []byte) {
	fake.stdoutChannelMutex.Lock()
	defer fake.stdoutChannelMutex.Unlock()
	fake.StdoutChannelStub = stub
}

func (fake *FakeJobData) StdoutChannelReturns(result1 chan []byte) {
	fake.stdoutChannelMutex.Lock()
	defer fake.stdoutChannelMutex.Unlock()
	fake.StdoutChannelStub = nil
	fake.stdoutChannelReturns = struct {
		result1 chan []byte
	}{result1}
}

func (fake *FakeJobData) StdoutChannelReturnsOnCall(i int, result1 chan []byte) {
	fake.stdoutChannelMutex.Lock()
	defer fake.stdoutChannelMutex.Unlock()
	fake.StdoutChannelStub = nil
	if fake.stdoutChannelReturnsOnCall == nil {
		fake.stdoutChannelReturnsOnCall = make(map[int]struct {
			result1 chan []byte
		})
	}
	fake.stdoutChannelReturnsOnCall[i] = struct {
		result1 chan []byte
	}{result1}
}

func (fake *FakeJobData) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.doneChannelMutex.RLock()
	defer fake.doneChannelMutex.RUnlock()
	fake.errorChannelMutex.RLock()
	defer fake.errorChannelMutex.RUnlock()
	fake.stderrChannelMutex.RLock()
	defer fake.stderrChannelMutex.RUnlock()
	fake.stdoutChannelMutex.RLock()
	defer fake.stdoutChannelMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeJobData) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ collector.JobData = new(FakeJobData)
